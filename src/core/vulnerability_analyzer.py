"""Vulnerability analysis and attack chain detection module."""

from typing import Any

import networkx as nx
import pandas as pd

from src.utils.logging_config import get_logger

logger = get_logger(__name__)

# MITRE ATT&CK tactics mapping based on impact level
MITRE_ATTACK_IMPACT_MAP = {
    "RCE": "Execution",
    "Privilege Escalation": "Privilege Escalation",
    "Auth Bypass": "Initial Access",
    "Lateral Movement": "Lateral Movement",
}

# MITRE ATT&CK tactics mapping based on CWE (top 25)
MITRE_ATTACK_CWE_MAP = {
    "CWE-79": "Execution",
    "CWE-89": "Credential Access",
    "CWE-287": "Defense Evasion",
    "CWE-502": "Execution",
    "CWE-269": "Privilege Escalation",
    "CWE-200": "Discovery",
    "CWE-77": "Execution",
    "CWE-94": "Execution",
    "CWE-611": "Execution",
    "CWE-798": "Credential Access",
    "CWE-119": "Execution",
    "CWE-190": "Privilege Escalation",
    "CWE-284": "Privilege Escalation",
    "CWE-434": "Execution",
    "CWE-732": "Privilege Escalation",
    "CWE-601": "Lateral Movement",
    "CWE-306": "Defense Evasion",
    "CWE-352": "Initial Access",
    "CWE-522": "Credential Access",
    "CWE-125": "Execution",
    "CWE-918": "Execution",
    "CWE-640": "Defense Evasion",
    "CWE-476": "Execution",
    "CWE-862": "Privilege Escalation",
}


class AttackChainAnalyzer:
    """Analyzes attack chains by constructing vulnerability dependency graphs."""

    def __init__(self, df: pd.DataFrame) -> None:
        """Initialize the attack chain analyzer.

        Args:
            df: DataFrame containing CVE data with columns:
                'cve_id', 'impact', 'severity', 'cwe'

        """
        self.df = df
        self.attack_graph = nx.DiGraph()
        self.build_graph()

    @staticmethod
    def map_to_mitre(impact: str, cwe: str) -> str:
        """Map CVE impact and CWE to MITRE ATT&CK tactics.

        Args:
            impact: Impact type (e.g., 'RCE', 'Privilege Escalation')
            cwe: CWE identifier (e.g., 'CWE-79')

        Returns:
            MITRE ATT&CK tactic name

        """
        # Try impact mapping first
        if impact in MITRE_ATTACK_IMPACT_MAP:
            return MITRE_ATTACK_IMPACT_MAP[impact]

        # Fall back to CWE mapping
        if cwe in MITRE_ATTACK_CWE_MAP:
            return MITRE_ATTACK_CWE_MAP[cwe]

        return "Unknown"

    def build_graph(self) -> None:
        """Build a directed graph of attack chains using Pandas operations.

        Creates nodes for each CVE and edges representing attack progression
        from higher-impact to lower-impact vulnerabilities sharing CWE.
        """
        # Impact severity ordering
        impact_order = {
            "Critical": 5,
            "RCE": 4,
            "Privilege Escalation": 3,
            "High": 3,
            "Auth Bypass": 2,
            "Medium": 2,
            "Lateral Movement": 1,
            "Low": 1,
        }

        # Add MITRE phase column
        self.df["mitre_phase"] = self.df.apply(
            lambda row: self.map_to_mitre(row.get("impact", ""), row.get("cwe", "")),
            axis=1,
        )

        # Add nodes from DataFrame
        nodes_data = self.df.set_index("cve_id")[
            ["impact", "severity", "cwe", "mitre_phase"]
        ].to_dict("index")
        self.attack_graph.add_nodes_from(nodes_data.items())

        # Create impact ordering for edge detection
        impact_df = self.df.copy()
        impact_df["impact_order"] = impact_df["impact"].map(impact_order)
        impact_df["severity_order"] = impact_df["severity"].map(impact_order)

        # Find edges: higher impact CVEs â†’ lower impact CVEs with same CWE
        attack_edges = impact_df.merge(
            impact_df,
            on="cwe",
            suffixes=("_higher", "_lower"),
        ).query(
            "impact_order_higher > impact_order_lower "
            "& severity_order_higher > severity_order_lower "
            "& cve_id_higher != cve_id_lower",
        )

        # Add edges to graph
        self.attack_graph.add_edges_from(
            attack_edges[["cve_id_higher", "cve_id_lower"]].to_records(index=False),
        )

        logger.debug(
            f"Built attack graph with {len(self.attack_graph.nodes)} nodes "
            f"and {len(self.attack_graph.edges)} edges",
        )

    def find_unique_chains(self) -> list[tuple[str, ...]]:
        """Identify unique attack paths from entry points to critical vulnerabilities.
        Optimized to prevent exponential runtime with large vulnerability sets.
        Returns:
            List of attack chains, sorted by length (longest first)

        """
        unique_chains: set[tuple[str, ...]] = set()

        # Get entry points (nodes with no predecessors) - potential attack entry points
        entry_points = [
            node
            for node in self.attack_graph.nodes()
            if self.attack_graph.in_degree(node) == 0
        ]

        # Get critical/high severity nodes - high-value targets
        critical_nodes = [
            node
            for node in self.attack_graph.nodes()
            if self.attack_graph.nodes[node].get("severity_reassessed")
            in ["Critical", "High"]
        ]

        # If no critical nodes found, use nodes with high severity or impact
        if not critical_nodes:
            critical_nodes = [
                node
                for node in self.attack_graph.nodes()
                if self.attack_graph.nodes[node].get("severity", "").lower()
                in ["critical", "high"]
            ]

        # Limit search scope to prevent exponential blowup
        # Only check reasonable number of entry points and targets
        limited_entry_points = (
            entry_points[:50] if len(entry_points) > 50 else entry_points
        )
        limited_critical_nodes = (
            critical_nodes[:50] if len(critical_nodes) > 50 else critical_nodes
        )

        # Only find paths between entry points and critical nodes (not all pairs)
        for start_node in limited_entry_points:
            for end_node in limited_critical_nodes:
                if start_node != end_node:
                    try:
                        # Limit path search depth to prevent explosion
                        paths = list(
                            nx.all_simple_paths(
                                self.attack_graph,
                                source=start_node,
                                target=end_node,
                                cutoff=5,  # Maximum 5 hops in attack chain
                            ),
                        )
                        # Limit number of paths per node pair to prevent memory issues
                        for path in paths[:10]:  # Max 10 paths per pair
                            unique_chains.add(tuple(path))
                    except (nx.NetworkXNoPath, nx.NetworkXError):
                        continue

        # If no chains found, try a broader but still limited search
        if not unique_chains and entry_points and critical_nodes:
            # Try a few more combinations with looser limits
            for start_node in entry_points[:20]:
                for end_node in critical_nodes[:20]:
                    if start_node != end_node:
                        try:
                            paths = list(
                                nx.all_simple_paths(
                                    self.attack_graph,
                                    source=start_node,
                                    target=end_node,
                                    cutoff=3,  # Shorter paths for fallback
                                ),
                            )
                            for path in paths[:5]:  # Fewer paths for fallback
                                unique_chains.add(tuple(path))
                        except (nx.NetworkXNoPath, nx.NetworkXError):
                            continue

        return sorted(unique_chains, key=len, reverse=True)

    def get_critical_paths(self, min_length: int = 2) -> list[tuple[str, ...]]:
        """`
        Get critical attack paths of minimum length.
        Optimized to work with the targeted chain finding approach.
        Args:
            min_length: Minimum path length to include
        Returns:
            List of critical attack chains

        """
        # Use the optimized chain finding
        chains = self.find_unique_chains()
        return [chain for chain in chains if len(chain) >= min_length]

    def get_node_impact(self, cve_id: str) -> dict[str, Any]:
        """Get impact metrics for a specific CVE node.

        Args:
            cve_id: CVE identifier

        Returns:
            Dictionary with impact metrics

        """
        if cve_id not in self.attack_graph.nodes:
            return {}

        node_data = self.attack_graph.nodes[cve_id]
        in_degree = self.attack_graph.in_degree(cve_id)
        out_degree = self.attack_graph.out_degree(cve_id)

        return {
            "cve_id": cve_id,
            "impact": node_data.get("impact"),
            "severity": node_data.get("severity"),
            "cwe": node_data.get("cwe"),
            "mitre_phase": node_data.get("mitre_phase"),
            "predecessors": in_degree,
            "successors": out_degree,
            "is_entry_point": in_degree == 0,
            "is_terminal": out_degree == 0,
        }

    def get_graph_statistics(self) -> dict[str, Any]:
        """Get overall attack graph statistics.

        Returns:
            Dictionary with graph metrics

        """
        nodes = self.attack_graph.nodes()
        edges = self.attack_graph.edges()

        return {
            "total_nodes": len(nodes),
            "total_edges": len(edges),
            "density": nx.density(self.attack_graph),
            "is_dag": nx.is_directed_acyclic_graph(self.attack_graph),
            "num_weakly_connected_components": nx.number_weakly_connected_components(
                self.attack_graph,
            ),
        }
